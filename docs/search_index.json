[
["data-description.html", "Chapter 4 Data Description", " Chapter 4 Data Description This section will describe the data used in this project. As described in the last section, the data used in this project comes from a recent study performed by NASA’s JPL. The study compiled all freely available groundwater data in the Central Valley of CA from different sources and synthesized it. Data were collected from 5 different sources across two different agencies: the USGS and the California Department of Water Resources (DWR). As noted, duplicates and wells without sufficient data were filtered out and a “representative” well was chosen for each square kilometer that had at least one well available. First, we can load the dataset and inspect. It contains 9 different variables, including 5 that relate to various identification numbers. There are lat/long variables describing the geographic reference, a depth to GW, and a date at which the depth measurement was taken, as seen in Table @ref(tab:master_tab). load(&quot;code/master.Rda&quot;) head(master) ## NDI site_no SITE_CODE STATION mergeOn lat lon date ## 1 0 3.23233e+14 3.23233E+14 32.54 -117.03 2010-03-04 ## 2 0 3.23233e+14 3.23233E+14 32.54 -117.03 2010-03-19 ## 3 0 3.23233e+14 3.23233E+14 32.54 -117.03 2010-05-06 ## 4 0 3.23233e+14 3.23233E+14 32.54 -117.03 2010-05-25 ## 5 0 3.23233e+14 3.23233E+14 32.54 -117.03 2010-07-09 ## 6 0 3.23233e+14 3.23233E+14 32.54 -117.03 2010-09-22 ## depth.to.GW..ft. ## 1 22.93 ## 2 22.87 ## 3 21.84 ## 4 21.22 ## 5 20.76 ## 6 20.09 A histogram can show us the time distribution of measurements for the entire dataset, as shown in Figure @ref(fig:mast_hist_fig) # Create a histogram of the entire dataset hist(master$date, &#39;years&#39;, xlab = &quot;Date&quot;, freq = TRUE, format = &quot;%Y&quot;) In understanding the spatial locations of these wells, we will need to display each well. However, in order to do this, we need to first extract the wells from the master dataset so that we are not mapping them twice. Once we have that, we can create a map using Leaflet that shows all of the wells in the dataset.A polygon outlining the central valley has also been included in blue. library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(leaflet) # Create a master list of all wells master_wells &lt;- distinct(master, mergeOn, .keep_all = TRUE)[,1:7] # we must keep some columns as chr b/c some have letters master_wells$NDI &lt;- as.character(master_wells$NDI) # Load in a geojson file that outlines the central valley CV_shape &lt;- geojsonio::geojson_read(&quot;code/CA_Bulletin_118_Aquifer_Regions_dissolved.geojson&quot;, what = &quot;sp&quot;) # Create a leaflet map of the all wells in the dataset with the central valley outline leaflet() %&gt;% addTiles() %&gt;% addPolygons(data = CV_shape, stroke = FALSE, smoothFactor = 0.3, fillOpacity = 0.5) %&gt;% addMarkers(data = master_wells, lng = ~lon, lat = ~lat, popup = ~NDI, clusterOptions = markerClusterOptions()) In order to clean this data to make it more manageable, we are going to filter out all wells that do not have more than 180 observations and do not fall within the central valley boundary polygon. library(sf) ## Linking to GEOS 3.8.1, GDAL 3.1.1, PROJ 6.3.1 library(tidyverse) ## ── Attaching packages ───────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 ## ✓ tibble 3.0.3 ✓ stringr 1.4.0 ## ✓ tidyr 1.1.2 ✓ forcats 0.5.0 ## ✓ readr 1.4.0 ## ── Conflicts ──────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() # Find datasets that have at least 180 observations (enough data points for monthly data across 15 years - this is just a screening value) master_count &lt;- as.data.frame(table(master$mergeOn)) w180 &lt;- master_count %&gt;% filter(Freq &gt; 180) %&gt;% merge(master_wells, by.x = &quot;Var1&quot;, by.y = &quot;mergeOn&quot;) %&gt;% rename(mergeOn = Var1) # Find 180 wells that fall within CV boundaries # We&#39;ll transform the w180 and CV_shape data objects to simple feature geometry objects pts &lt;- st_as_sf(x = w180, coords = c(&quot;lon&quot;, &quot;lat&quot;)) st_crs(pts) &lt;- st_crs(CV_shape) CV_shape &lt;- st_as_sf(x = CV_shape) # Now we&#39;ll intersect the two data objects and create a data frame CV_wells &lt;- CV_shape %&gt;% st_intersection(pts) %&gt;% extract(col = geometry, into = c(&#39;long&#39;, &#39;lat&#39;), &#39;\\\\((.*), (.*)\\\\)&#39;, convert = TRUE) %&gt;% as.data.frame() %&gt;% subset(select = -c(Basin_Name, Shape_Length, Shape_Area, geometry)) %&gt;% subset(select = -c(geometry)) ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ## Warning: attribute variables are assumed to be spatially constant throughout all ## geometries After an initial cleaning, the dataset can be further refined to find data that meet our criteria. For this analysis, we’d like as consistent of a database as possible, so we’ll filter out data that doesn’t span at least 15 years. library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union # Next, we need to find the wells that have data that span across at least 15 years. ## In addition, we would like to find data with an adequate distribution: ### We&#39;ll do this by looping through the data to find wells with at least 4 data points per year. w15 &lt;- list() for (well in CV_wells$mergeOn) { ts &lt;- filter(master, mergeOn == well) diff &lt;- as.integer(max(ts$date) - min(ts$date)) yr_dist &lt;- as.data.frame(table(year(ts$date))) add &lt;- TRUE if (diff &gt; 5475){ for (yr_freq in yr_dist$Freq) { if (yr_freq &lt; 4){ add = FALSE } } if (add == TRUE) { w15 &lt;- append(w15, well) } } } Finally, the data can be summarized into 3 month blocks. Then, wells with coverage over the entire timeframe (19 years in this case) will be kept for further analysis. Once those wells are identified, a proper spatial distribution will need to be determined. # Next, we&#39;ll find wells that have at least one measurement every 3 months for 19 years w76 &lt;- data.frame(c()) for (well in w15){ ts &lt;- filter(master, mergeOn == well) mon_ts &lt;- ts %&gt;% mutate(dategroup = lubridate::floor_date(date, &quot;3 months&quot;)) %&gt;% group_by(dategroup) %&gt;% summarize(Mean_depth=mean(depth.to.GW..ft.)) if (nrow(mon_ts) &gt;= 76){ w76 &lt;- rbind(w76, well) } } ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) ## `summarise()` ungrouping output (override with `.groups` argument) # This creates a dataframe with wells with data spanning 15 years w76 &lt;- w76 %&gt;% rename(mergeOn = colnames(w76)) %&gt;% merge(CV_wells, by = &quot;mergeOn&quot;) # Create another leaflet map of the wells that span 15+ years leaflet() %&gt;% addTiles() %&gt;% addPolygons(data = CV_shape, stroke = FALSE, smoothFactor = 0.3, fillOpacity = 0.5) %&gt;% addMarkers(data = w76, lng = ~long, lat = ~lat, popup = ~mergeOn ) For this analysis, we need a small cluster of wells that are within a reasonable (~50 km) from each other. A certain distance could be set as a threshold, and R could be used to determine a proper cluster programmatically. However, in this case, it is easier to manually determine a good cluster of wells. Based on the map, wells 25N03W11B003M, 29N03W18M001M, 24N02W29N004M, 24N02W24D003M, and 24N02W03B001M were chosen (the area will be displayed a little later on). A facet-wrapped histogram shows the distribtion of these wells’ measurements. # From the map, we identified 5 wells that are grouped together. test_wells &lt;- c(&#39;25N03W11B003M&#39;, &#39;29N03W18M001M&#39;, &#39;24N02W29N004M&#39;, &#39;24N02W24D003M&#39;, &#39;24N02W03B001M&#39;) # Now we can create a time series list, histogram mosaic, and well list. test_ts &lt;- subset(master, mergeOn %in% test_wells) ggplot(test_ts, aes(x=date)) + geom_histogram(bins = 19*4) + facet_wrap(~mergeOn) These wells will make up the basis for the remainder of this study. This final map includes a red box identifying the 5 wells that were chosen. # Final leaflet map with study area in red leaflet() %&gt;% addTiles() %&gt;% addPolygons(data = CV_shape, stroke = FALSE, smoothFactor = 0.3, fillOpacity = 0.5) %&gt;% addMarkers(data = w76, lng = ~long, lat = ~lat, popup = ~mergeOn ) %&gt;% addRectangles(lng1 = -121.4, lat1 = 38.7, lng2 = -122, lat2 = 39.1, color = &quot;#ff0000&quot;, opacity = 0.9, fillColor = &quot;transparent&quot;) You can write citations, too. For example, we are using the bookdown package (Xie 2020) in this sample book, which was built on top of R Markdown and knitr (???). References "]
]
